<!doctype html>
<html class="no-js" lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <title>Make You A Language</title>
  <link rel="stylesheet" href="style.scss">
  <style>
    body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
    }
  </style>
<!-- <meta name="description" content=""> -->

  <!-- <link rel="icon" href="/icon.svg" type="image/svg+xml"> -->

  <!-- <link rel="manifest" href="site.webmanifest"> -->
  <!-- <meta name="theme-color" content="#fafafa"> -->
</head>

<body>
  <div id="elm"></div>
  <!-- <script type="module" src="index.js"></script> -->
   <!-- <script type="text/javascript" src="hot.js"></script> -->
   <script type="module">
    import { Elm } from './src/Main.elm'

    function startElm(db, packages) {
      /* various helper functions */
      function pointInRect(x, y, rect) {
        return x >= rect.x && x <= rect.x + rect.w &&
              y >= rect.y && y <= rect.y + rect.h;
      }

      function isInsideAnyRect(x, y, rects) {
        return rects.some(r => pointInRect(x, y, r));
      }

      let panIntervalId = null;
      let mx = -1;
      let my = -1;
      let uuids = new Map();
      let windowHasFocus = true;
      let sentCoordinates = new Map();

      // event to track the mouse coordinates constantly and put them into (mx, my)
      addEventListener("pointermove", (e) => {
        mx = e.clientX;
        my = e.clientY;
        for (const [uuid, data] of uuids) {
          // don't kick off a new pan while we're already panning
          if (!data.active) {
            check(uuid, data.rects);
          }
        }
      });

      // Window focus
      window.addEventListener('blur', () => {
        windowHasFocus = false;
      });

      window.addEventListener('focus', () => {
        windowHasFocus = true;
      });

      function panWhile(uuid, rects) {
        if (uuids.has(uuid) && isInsideAnyRect(mx, my, rects)) {
          if (!document.hidden && windowHasFocus) {
            app.ports.pan.send({ uuid : uuid, x : mx, y : my });
          }
          setTimeout(() => panWhile(uuid, rects), 40);
        } else {
          uuids.delete(uuid);
        }
      }

      function check(uuid, rects) {
        if (!isInsideAnyRect(mx, my, rects)) {
          return;
        }
        // establish stability
        let mx_ = mx;
        let my_ = my;
        setTimeout(() => {
          if (mx == mx_ && my == my_) {
            // I have stability.
            uuids.set(uuid, { rects : rects, active : true });
            panWhile(uuid, rects);
          }
        }, 150);
      }

      /* END various helper functions */

      const random_seeds = new Uint32Array(5);
      crypto.getRandomValues(random_seeds);

      const flags =
        { width : document.getElementsByTagName('html')[0].clientWidth
        , height : document.getElementsByTagName('html')[0].clientHeight
        , initialSeed : random_seeds[0]
        , extendedSeeds : Array.from(random_seeds.slice(1))
        , startTime : Date.now()
        , packages : packages
        };

      let app = Elm.Main.init({ flags: flags, node: document.getElementById('elm') });

      app.ports.requestCoordinates.subscribe((uuid) => {
        const elem = document.getElementById(uuid);
        if (elem === null) return;
        const box = elem.getBoundingClientRect();
        const result = { uuid: uuid, x : box.left, y : box.top };
        // to avoid sending unnecessary messages, check: have I sent this _exact_
        // message before?  I only need to send such a message once.
        // console.log(result);
        const alreadySent = sentCoordinates.get(uuid);
        // we can't compare for structural equality without bringing in an external
        // library because it's 2025 and who needs that anyway, right? Right?
        if (alreadySent !== undefined && alreadySent.x === result.x && alreadySent.y === result.y) return;
        sentCoordinates.set(uuid, result); // add it.
        setTimeout(() => app.ports.receiveCoordinates.send(result), 1);
      });

      app.ports.considerPan.subscribe((item) => {
        // console.log(item);
        uuids.set(item.uuid, { rects : item.rectangles, active : false });
      });

      app.ports.stopPan.subscribe((uuid) => {
        // console.log("Stop-pan");
        // console.log(uuid);
        uuids.delete(uuid);
      });

      app.ports.saveToStorage.subscribe((item) => {
        console.log(item);
        const put_request =
          db.transaction(["computations"], "readwrite")
          .objectStore("computations")
          .put(item);
        put_request.onsuccess = (e) => {
          // it exists; update it.
          console.log("Updated/Inserted " + item.graph.uuid);
          // console.log(e.target.result);
        };
      });

      app.ports.deleteFromStorage.subscribe((uuid) => {
        const store = db.transaction(["computations"], "readwrite").objectStore("computations");
        const delete_request = store.delete(uuid);
        delete_request.onsuccess = (e) => {
          if (e.target.result === undefined) {
            console.log("Deletion successful " + uuid);
          }
        }
      });
    }

      // Initialize the Elm app with viewport dimensions
      // We also use 8 'extended' seeds for the PCG generator. Technically,
      // this should give us a period of 2^(5*32) or 1.461â€¯501â€¯637 Ã— 10^48.
      // A V4 UUID has 122 bits of randomness, so 5.316â€¯911â€¯983 Ã— 10^36.
      // So I'm reasonably happy with how the period is matching up here.

    function doInitialLoad(db) {
      db.transaction(["computations"], "readonly")
      .objectStore("computations")
      .getAll()
      .onsuccess = (e) => {
        console.log(e.target.result);
        setTimeout(startElm, 1, db, e.target.result);
      };
    }

    // right, let's create and initialize a database!
    const db_open = indexedDB.open("tahira");
    db_open.onerror = (err) => {
      console.error(`Database open error: ${event.target.error?.message}`);
    };
    db_open.onupgradeneeded = (e) => { // also called during initial creation
      // right now, there's only one version, so I'm going to be v.lazy.
      const mydb = e.target.result;
      const computations = mydb.createObjectStore("computations", { "keyPath" : "graph.uuid" });
    };
    db_open.onsuccess = (e) => {
      e.target.result.onerror = (err) => {
        // set up the error handler that every db error will bubble up to
        console.error(`Database error: ${event.target.error?.message}`);
      };
      setTimeout(doInitialLoad, 1, e.target.result);
    };

    // ======= Focus on #quick-input whenever it appears.
    // ======= Because the `autofocus` attribute only works on initial load
    // ======= and this vast amount of code is, apparently, the normal and
    // ======= accepted way to do things ðŸ”¥
    // ======= and it is 2025 ðŸ”¥ðŸ”¥
    // ======= and everything is fine ðŸ”¥ðŸ”¥ðŸ”¥

    // Create a MutationObserver to watch for DOM changes
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        // Check if the quick-input element exists
        const quickInput = document.getElementById('quick-input');
        
        if (quickInput) {
          // Remove any existing event listeners to prevent duplicates
          quickInput.removeEventListener('focus', preventDefaultFocus);
          
          // Focus on the element
          quickInput.focus();
          
          // Add a temporary event listener to prevent default focus behavior
          // This ensures our focus takes precedence
          quickInput.addEventListener('focus', preventDefaultFocus, { once: true });
        }
      });
    });

    // Helper function to prevent default focus behavior
    function preventDefaultFocus(e) {
      e.preventDefault();
    }

    // Configure the observer to watch for:
    // - Added nodes (childList: true)
    // - Subtree changes to watch nested elements (subtree: true)
    const observerConfig = {
      childList: true,
      subtree: true
    };

    // Start observing the document body
    observer.observe(document.body, observerConfig);

    // Also check immediately in case the element already exists
    const existingQuickInput = document.getElementById('quick-input');
    if (existingQuickInput) {
      existingQuickInput.focus();
    }

    // To stop observing when no longer needed:
    // observer.disconnect();

    // Instead of the above, I could always use some sort of `Task`
    // and `Process.sleep` and `Dom.focus` and all of that from Elm
    // â€¦ just kidding, that stuff is so error-prone and janky that I'd
    // be heisenbugging all over the place for years.
    // No, I'll just go with JavaScript and call it a day.

   </script>
</body>

</html>