<!doctype html>
<html class="no-js" lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <title>Make You A Language</title>
  <link rel="stylesheet" href="style.scss">
  <style>
    body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
    }
  </style>
<!-- <meta name="description" content=""> -->

  <!-- <link rel="icon" href="/icon.svg" type="image/svg+xml"> -->

  <!-- <link rel="manifest" href="site.webmanifest"> -->
  <!-- <meta name="theme-color" content="#fafafa"> -->
</head>

<body>
  <div id="elm"></div>
  <!-- <script type="module" src="index.js"></script> -->
   <!-- <script type="text/javascript" src="hot.js"></script> -->
   <script type="module">
    import { Elm } from './src/Main.elm'

    function startElm(db, packages) {

      /******************************************
       * 
       * Panning.
       * 
       ******************************************/
      // not to be confused with the animation studio
      // const clamp = (min, max, v) => Math.min(Math.max(v, min), max);

      let panIntervalId = null;
      let mx = -1;
      let my = -1;
      let windowHasFocus = true;
      let mouse_left = '';

      // event to track the mouse coordinates constantly and put them into (mx, my)
      addEventListener("pointermove", (e) => {
        mx = e.clientX;
        my = e.clientY;
      });

      // Window focus
      window.addEventListener('blur', () => {
        windowHasFocus = false;
      });

      window.addEventListener('focus', () => {
        windowHasFocus = true;
      });

      function panWhile(uuid, element) {
        if (!element.isConnected) {
          return; // no longer exists; we're done!
        }
        if (mouse_left == uuid) {
          app.ports.stopPan.send(uuid);
          return;
        }
        const rect = element.getBoundingClientRect();
        if (isNearEdge(mx, my, rect)) {
          console.log("Near edge.");
          if (!document.hidden && windowHasFocus) {
            const coordinates = detectEdgeRegion(mx, my, rect);
            if (coordinates) {
              app.ports.pan.send({ uuid : uuid, pan : coordinates });
            }
          }
          setTimeout(() => panWhile(uuid, element), 40);
        } else if (isInBounds(mx, my, rect)) {
          console.log("In bounds.");
          // no longer on an edge.
          app.ports.stopPan.send(uuid);
          setTimeout(() => considerPan(uuid, element), 40);
        } else {
          console.log("Out of bounds.");
          // out of the element area entirely; no recursion.
          app.ports.stopPan.send(uuid);
        }
      }

      function considerPan(uuid, element) {
        // this is called on mouseenter.
        // mouseenter means we're already in the element, so just check edge proximity
        const rect = element.getBoundingClientRect();
        // console.log("Mouse entered.");
        if (rect.width < 80 || rect.height < 80) return;
        if (isNearEdge(mx, my, rect)) {
          // console.log("Near edge.");
          // establish stability
          let mx_ = mx;
          let my_ = my;
          setTimeout(() => {
            if (mx == mx_ && my == my_) {
              // I have stability.
              // console.log("Stability established.");
              panWhile(uuid, element);
            } else if (isInBounds(mx, my, rect)) {
              // console.log("In bounds.");
              setTimeout(() => considerPan(uuid, element), 40);
            }
          }, 150);
        } else if (isInBounds(mx, my, rect)) {
          // console.log("In bounds.");
          setTimeout(() => considerPan(uuid, element), 40);
        } // otherwise, I'm out of the element area entirely; silently return & die.
      }

      function isInBounds(mx, my, rect) {
        return mx > rect.left && mx < rect.right && my > rect.top && my < rect.bottom;
      }

      // Create a MutationObserver to watch for DOM changes.
      // MutationObserver setup.
      // This code was created with the assistance of Thaura.
      const panObserver = new MutationObserver((mutations) => {
        let added = new Set();
        const add_listeners = (container) => {
          const attr = container.getAttribute('graph-id');
          if (added.has(container)) {
            console.log("Already added uuid " + attr + "; ignoring.");
            return;
          }
          container.addEventListener('mouseenter', handleGraphMouseEnter);
          container.addEventListener('mouseleave', () => { mouse_left = attr; });
          added.add(container);
          console.log("Added " + attr);
        };
        
        mutations.forEach((mutation) => {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType === Node.ELEMENT_NODE && 
                node.classList.contains('graph-container') && 
                node.hasAttribute('graph-id')) {
              add_listeners(node);
            }
            
            // Check child nodes
            if (node.querySelectorAll) {
              const containers = node.querySelectorAll('div.graph-container[graph-id]');
              containers.forEach(add_listeners);
            }
          });
        });
      });

      // Start observing the document
      panObserver.observe(document.body, {
        childList: true,
        subtree: true
      });

      // Simplified handler using mouseenter
      function handleGraphMouseEnter(event) {
        const element = event.currentTarget;
        const attr = element.getAttribute('graph-id');
        if (mouse_left == attr) {
          mouse_left = '';
        }
        considerPan(attr, element);
      }

      // Check if mouse is within 40px of any edge
      function isNearEdge(mx, my, rect) {
        const edgeDistance = 40;
        const left = mx - rect.left;
        const right = rect.right - mx;
        const top = my - rect.top;
        const bottom = rect.bottom - my;

        if (left < 0 || right < 0 || top < 0 || bottom < 0) return false;
        
        return Math.min(left, right, top, bottom) <= edgeDistance;
      }

      function detectEdgeRegion(mx, my, rect) {
        const edgeDistance = 40;
        const left = mx - rect.left;
        const right = rect.right - mx;
        const top = my - rect.top;
        const bottom = rect.bottom - my;
        
        // Check corners first
        if (left <= edgeDistance && top <= edgeDistance) return { pan_x: -1, pan_y: -1 };
        if (right <= edgeDistance && top <= edgeDistance) return { pan_x: 1, pan_y: -1 };
        if (left <= edgeDistance && bottom <= edgeDistance) return { pan_x: -1, pan_y: 1 };
        if (right <= edgeDistance && bottom <= edgeDistance) return { pan_x: 1, pan_y: 1 };
        
        // Check edges
        if (top <= edgeDistance) return { pan_x: 0, pan_y: -1 };
        if (bottom <= edgeDistance) return { pan_x: 0, pan_y: 1 };
        if (left <= edgeDistance) return { pan_x: -1, pan_y: 0 };
        if (right <= edgeDistance) return { pan_x: 1, pan_y: 0 };
        
        return null;
      }

      /* END panning */

      const random_seeds = new Uint32Array(5);
      crypto.getRandomValues(random_seeds);

      const flags =
        { width : document.getElementsByTagName('html')[0].clientWidth
        , height : document.getElementsByTagName('html')[0].clientHeight
        , initialSeed : random_seeds[0]
        , extendedSeeds : Array.from(random_seeds.slice(1))
        , startTime : Date.now()
        , packages : packages
        };

      let app = Elm.Main.init({ flags: flags, node: document.getElementById('elm') });

      app.ports.saveToStorage.subscribe((item) => {
        console.log(item);
        const put_request =
          db.transaction(["computations"], "readwrite")
          .objectStore("computations")
          .put(item);
        put_request.onsuccess = (e) => {
          // it exists; update it.
          console.log("Updated/Inserted " + item.uuid);
          // console.log(e.target.result);
        };
      });

      app.ports.deleteFromStorage.subscribe((uuid) => {
        const store = db.transaction(["computations"], "readwrite").objectStore("computations");
        const delete_request = store.delete(uuid);
        delete_request.onsuccess = (e) => {
          if (e.target.result === undefined) {
            console.log("Deletion successful " + uuid);
          }
        }
      });
    }

      // Initialize the Elm app with viewport dimensions
      // We also use 8 'extended' seeds for the PCG generator. Technically,
      // this should give us a period of 2^(5*32) or 1.461â€¯501â€¯637 Ã— 10^48.
      // A V4 UUID has 122 bits of randomness, so 5.316â€¯911â€¯983 Ã— 10^36.
      // So I'm reasonably happy with how the period is matching up here.

    function doInitialLoad(db) {
      db.transaction(["computations"], "readonly")
      .objectStore("computations")
      .getAll()
      .onsuccess = (e) => {
        console.log(e.target.result);
        setTimeout(startElm, 1, db, e.target.result);
      };
    }

    // right, let's create and initialize a database!
    const db_open = indexedDB.open("tahira");
    db_open.onerror = (err) => {
      console.error(`Database open error: ${event.target.error?.message}`);
    };
    db_open.onupgradeneeded = (e) => { // also called during initial creation
      // right now, there's only one version, so I'm going to be v.lazy.
      const mydb = e.target.result;
      const computations = mydb.createObjectStore("computations", { "keyPath" : "uuid" });
    };
    db_open.onsuccess = (e) => {
      e.target.result.onerror = (err) => {
        // set up the error handler that every db error will bubble up to
        console.error(`Database error: ${event.target.error?.message}`);
      };
      setTimeout(doInitialLoad, 1, e.target.result);
    };

    // ======= Focus on #quick-input whenever it appears.
    // ======= Because the `autofocus` attribute only works on initial load
    // ======= and this vast amount of code is, apparently, the normal and
    // ======= accepted way to do things ðŸ”¥
    // ======= and it is 2025 ðŸ”¥ðŸ”¥
    // ======= and everything is fine ðŸ”¥ðŸ”¥ðŸ”¥

    // Create a MutationObserver to watch for DOM changes
    const quickInputObserver = new MutationObserver((mutations) => {
      // mutations.forEach((mutation) => {
        // Check if the quick-input element exists
        const quickInput = document.getElementById('quick-input');
        
        if (quickInput) {
          // Remove any existing event listeners to prevent duplicates
          quickInput.removeEventListener('focus', preventDefaultFocus);
          
          // Focus on the element
          quickInput.focus();
          
          // Add a temporary event listener to prevent default focus behavior
          // This ensures our focus takes precedence
          quickInput.addEventListener('focus', preventDefaultFocus, { once: true });
        }
      // });
    });

    // Helper function to prevent default focus behavior
    function preventDefaultFocus(e) {
      e.preventDefault();
    }

    // Configure the observer to watch for:
    // - Added nodes (childList: true)
    // - Subtree changes to watch nested elements (subtree: true)
    const quickInputObserverConfig = {
      childList: true,
      subtree: true
    };

    // Start observing the document body
    quickInputObserver.observe(document.body, quickInputObserverConfig);

    // Also check immediately in case the element already exists
    const existingQuickInput = document.getElementById('quick-input');
    if (existingQuickInput) {
      existingQuickInput.focus();
    }

    // To stop observing when no longer needed:
    // observer.disconnect();

    // Instead of the above, I could always use some sort of `Task`
    // and `Process.sleep` and `Dom.focus` and all of that from Elm
    // â€¦ just kidding, that stuff is so error-prone and janky that I'd
    // be heisenbugging all over the place for years.
    // No, I'll just go with JavaScript and call it a day.

   </script>
</body>

</html>